# JAVA 8实战笔记

1. 主要内容
   - lambda表达式
   - 默认方法
   - 新的集合处理api：流
   - 新日期api: java.time

## 一、 lambda表达式:java中对函数式编程的支持

### 1. 基本概念

#### 1.1 什么是函数式编程

函数式编程（英语：functional programming）或称函数程序设计，又称泛函编程，是一种编程典范，它将**计算机运算**视为数学上的函数计算，并且避免使用程序状态以及易变对象。函数编程语言最重要的基础是**λ演算**（lambda calculus）。而且λ演算的函数可以接受函数当作输入（引数）和输出（传出值）。

#### 1.2 lambda表达式是什么？

其实就是不同程序语言对λ演算的实现。

#### 1.3 在java如何表示

java中的lambda表达式：其思想就是行为参数化（函数化），本质上是匿名函数的语言糖。

eg: () -> {}

### 2. 函数式接口：只有一个抽象方法的接口

1. 作用：函数描述符，声明该lambda表达式的输入(参数)/输出(返回值),即lambda表达式的方法签名。如 () -> Void,(Apple,Apple) -> int
2. @FunctionalInterface：编译时注解，告诉编译器以函数式接口的标准检查。
3. 为什么函数式接口只能有一个未实现的抽象方法：因为使用lambda表达式实际上还是传递的匿名对象，如果有两个抽象方法，java中要求该它的子类对象必须实现所有的方法，这样就不能写成现在的形式，故做了这样的规定。

### 3. lambda表达式

#### 3.1 类型检查、类型推断以及限制

1. 类型检查

    Lambda的类型是从使用Lambda的上下文推断出来的。上下文（比如，接受它传递的方法的
    参数，或接受它的值的局部变量）中Lambda表达式需要的类型称为目标类型。

    ```java
    // 接口声明
    filter(inventory, Predicate<Apple> p);

    //调用
    List<Apple> heavierThan150g =
    filter(inventory, (Apple a) -> a.getWeight() > 150);
    ```

    类型检查的过程：

    - 首先，你要找出filter方法的声明。
    - 第二，要求它是Predicate\<Apple>（目标类型）对象的第二个正式参数。
    - 第三，Predicate\<Apple>是一个函数式接口，定义了一个叫作test的抽象方法。
    - 第四，test方法描述了一个函数描述符，它可以接受一个Apple，并返回一个boolean。
    - 最后，filter的任何实际参数都必须匹配这个要求。即函数表达式必须是(Apple) -> boolean

2. 类型推断

    Java编译器会从上下文（目标类型）推断出用什么函数式接
    口来配合Lambda表达式，这意味着它也可以推断出适合Lambda的签名，因为函数描述符可以通
    过目标类型来得到。这样做的好处在于，编译器可以了解Lambda表达式的参数类型，这样就可
    以在Lambda语法中省去标注参数类型。换句话说，Java编译器会像下面这样推断Lambda的参数
    类型：

    ```java
    // 没有类型推断
    Comparator<Apple> c =
    (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());

    // 使用类型推断
    Comparator<Apple> c =
    (a1, a2) -> a1.getWeight().compareTo(a2.getWeight());
    ```

3. 在lambda中使用局部变量的限制（和匿名内部类使用外部类的局部变量的限制一样）

    对局部变量的限制
    你可能会问自己，为什么局部变量有这些限制。第一，实例变量和局部变量背后的实现有一
    个关键不同。实例变量都存储在堆中，而局部变量则保存在栈上（不同的线程不共享栈空间）。如果Lambda可以直接访问局
    部变量，而且Lambda是在一个线程中使用的，则使用Lambda的线程，可能会在分配该变量的线
    程将这个变量收回之后，去访问该变量。因此，Java在访问自由局部变量时，实际上是在访问它
    的副本，而不是访问原始变量。如果局部变量仅仅赋值一次那就没有什么区别了——因此就有了
    这个限制。
    第二，这一限制不鼓励你使用改变外部变量的典型命令式编程模式（我们会在以后的各章中
    解释，这种模式会阻碍很容易做到的并行处理）。

>闭包
你可能已经听说过闭包（closure，不要和Clojure编程语言混淆）这个词，你可能会想
Lambda是否满足闭包的定义。用科学的说法来说，闭包就是一个函数的实例，且它可以无限
制地访问那个函数的非本地变量。例如，闭包可以作为参数传递给另一个函数。它也可以访
问和修改其作用域之外的变量。现在，Java 8的Lambda和匿名类可以做类似于闭包的事情：
它们可以作为参数传递给方法，并且可以访问其作用域之外的变量。但有一个限制：它们不
能修改定义Lambda的方法的局部变量的内容。这些变量必须是隐式最终的。可以认为Lambda
是对值封闭，而不是对变量封闭。如前所述，这种限制存在的原因在于局部变量保存在栈上，
并且隐式表示它们仅限于其所在线程。如果允许捕获可改变的局部变量，就会引发造成线程
不安全的新的可能性，而这是我们不想看到的（实例变量可以，因为它们保存在堆中，而堆
是在线程之间共享的）。

#### 3.2 方法引用：lambda表达式的语法糖,即直接引用现有方法

方法引用可以被看作仅仅调用特定方法的Lambda的一种快捷
写法。它的基本思想是，如果一个Lambda代表的只是“直接调用这个方法”，那最好还是用名称
来调用它，而不是去描述如何调用它。事实上，方法引用就是让你根据已有的方法实现来创建
Lambda表达式。但是，显式地指明方法的名称，你的代码的可读性会更好

使用方式 **类名::方法名**

1. 构建方法引用

    - (1)指向静态方法的方法引用（例如Integer的parseInt方法，写作Integer::parseInt）。
    你的第一个
    方法引用！
    - (2)指向任意类型实例方法的方法引用（ 例如String 的length 方法， 写作
    String::length）。
    - (3)指向现有对象的实例方法的方法引用（假设你有一个局部变量expensiveTransaction
    用于存放Transaction类型的对象，它支持实例方法getValue，那么你就可以写expensive
    Transaction::getValue）。

```java
//(1) 调用某个类的静态方法
(args) -> ClassName.staticMethod(args)
等价于 ClassName::staticMethod

//(2) 调用某个类(arg0)的成员方法
(arg0,arg1) -> arg0.invoke(arg1)
等价于 arg0::invoke  

//(3) 调用对象实例的方法
(arg1) -> arg1.invoke()
等价于 arg1::invoke
```

#### 3.3 构造函数引用

```java
Supplier<MyClass> supplier = MyClass::new
等价于
Supplier<MyClass> supplier = () -> new MyClass();
```

## 默认方法

1. 默认方法的含义及其作用

## 流