#　程序执行相关的底程知识
cpu(执行线程代码)
指令
缓存/内存(存放操作数据)
总线

## 线程
## 进程

上下文切换(cpu切换线程执行)
    如何减少切换:无锁并发/cas算法/减少线程数量/协程
协程

死锁
    如何避免：不要同一个线程同一时间获取多个锁/避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。/尝试使用定时锁，使用lock.tryLock（timeout）来替代使用内部锁机制。/对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。


## java并发机制底程原理：

1. volatile  （Lock指令）/synchronized的作用和原理


2. synchronized

什么是锁：当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。Java中的每一个对象都可以作为锁
存储在哪：**对象头的mark word里**

·对于普通同步方法，锁是当前实例对象。
·对于静态同步方法，锁是当前类的Class对象。
·对于同步方法块，锁是Synchonized括号里配置的对象。

    Monitor  monitorenter/monitorexit

java se1.6中：锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状
态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏
向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高
获得锁和释放锁的效率

1. 原子操作的实现原理（总线锁/缓存锁）

原子（atomic）本意是“不能被进一步分割的最小粒子”，而原子操作（atomic operation）意为“不可被中断的一个或一系列操作”。

## Java内存模型

### 并发编程的两个关键问题：线程通信和同步(不同线程间操作发生的顺序)

线程通信：内存共享模式/消息传递模式

内存可见性

### java内存的抽象结构

- heap(线程共享)：实例域，静态域及数组元素
- 线程本地内存local memory（抽象概念）:局部域，方法定义参数，异常处理参数

Java线程之间的通信由Java内存模型（本文简称为JMM）控制，JMM决定一个线程对共享
变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽
象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地
内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的
一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优
化。

JMM在具体实现上的基本方针为：在不改变（正确同步的）程序执行结果的前提下，尽可能地为编译器和处理器的优化（重排序）打开方便之门。

### 从源码到指令的序列重排序

### happen-before（重要）

程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。
·监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。
·volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的
读。
·传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。

注：
两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个
操作之前执行！happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一
个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。
happens-before的定义很微妙，后文会具体说明happens-before为什么要这么定义。

## 重排序（优化执行：编译重排序和处理重排序）（重要）

### 数据依赖

如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间
就存在数据依赖性。

前面提到过，编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵
守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。

### as-if-serial语义

as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）
程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。

```java
int a = 1;
int b = 2;
int c = a + b;
```

上面的代码中 c依赖于a和b,a和b互不影响，所以c不会被重排序，他只能在a和b操作执行之后执行。但是a和b可能被重排序

as-if-serial语义把单线程程序保护了起来，遵守as-if-serial语义的编译器、runtime和处理器
共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。asif-
serial语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。

描述为happen-before规则：

    1 a happen-before b
    2 b happen-before c
    由1-2 a happen-before c

这里A happens-before B，但实际执行时B却可以排在A之前执行（看上面的重排序后的执
行顺序）。如果A happens-before B，JMM并不要求A一定要在B之前执行。JMM仅仅要求前一个
操作（执行的结果）对后一个操作可见，且前一个操作按顺序（并非执行）排在第二个操作之前。这里操作A
的执行结果不需要对操作B可见；而且重排序操作A和操作B后的执行结果，与操作A和操作B
按happens-before顺序执行的结果一致。在这种情况下，JMM会认为这种重排序并不非法（not
illegal），JMM允许这种重排序。

### 顺序一致性（内存参考模型：有序性）

顺序一致性内存模型是一个被计算机科学家理想化了的理论参考模型，它为程序员提供
了极强的内存可见性保证。顺序一致性内存模型有两大特性。
1）一个线程中的所有操作必须按照程序的顺序来执行。
2）（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内
存模型中，每个操作都必须原子执行且立刻对所有线程可见。（由于操作是原子必性的，不会出现资源竞争问题。）

数据竞争：多个线程中操作同一个共享变量，且存在至少一个写操作时，而且这些操作没有正确同步（即没有排序）。

顺序一致性：JMM对正确同步的多线程程序的内存一致性做了如下保证，如果程序是正确同步的，程序的执行将具有顺序一致性（Sequentially Consistent）——即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同


### 线程未正确同步的执行特性

最小安全性
总线的工作机制

### volatile的内存语义

可见性。对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。

原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。

#### volatile写-读建立的happens-before关系

上面讲的是volatile变量自身的特性，对程序员来说，volatile对线程的内存可见性的影响比volatile自身的特性更为重要

从JSR-133开始（即从JDK5开始），volatile变量的写-读可以实现线程之间的通信。

从内存语义的角度来说，volatile的写-读与锁的释放-获取有相同的内存效果：volatile写和锁的释放有相同的内存语义；volatile读与锁的获取有相同的内存语义。

#### voldatile语义

当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。

·线程A写一个volatile变量，实质上是线程A向接下来将要读这个volatile变量的某个线程
发出了（其对共享变量所做修改的）消息。
·线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出的（在写这个volatile
变量之前对共享变量所做修改的）消息。
·线程A写一个volatile变量，随后线程B读这个volatile变量，这个过程实质上是线程A通过
主内存向线程B发送消息。