# 精通正则表达式:文本匹配

正则表达式（Regular Expression）是强大、便捷、高效的文本处理工具。正则表达式本身，加上如同一门袖珍编程语言的通用模式表示法（general pattern notation），赋予使用者描述和分析文本的能力。配合上特定工具提供的额外支持，正则表达式能够添加、删除、分离、叠加、插入和修整各种类型的文本和数据。

完整的正则表达式由两种字符构成。特殊字符（special characters，例如搜索文件名时使用的通配符*）称为“元字符”（metacharacters），其他为“文字”（literal），或者是普通文本字符（normal text characters）。

在编写正则表达式的时候，我们必须进行权衡：**匹配符合要求的文本，同时忽略不符合要求的文本。**

## 一、基础

### 1.元字符:用于匹配某类字符的标识(参考JDK API java.util.regex里的类的说明)

元字符的类型：

- 字符匹配
- 字符组
- 预定义字符组
- 范围匹配/位置匹配
- 反向引用
- 捕获和非捕获

- 匹配行的开始:^
- 匹配行的结束:$
- 字符组(匹配若干字符之一):[],1[abc]表示匹配字符串"1a"或"1b"或"1c";
- 字符组连字符: [1-3]等价于[123]
- 排除型字符组(不希望匹配的字符)：[^123]，不希望匹配字符1或2或3，即匹配...之外的**任意一个**字符。
- 匹配任意一个字符:  "."
- 多选结构，匹配任意**子表达式**:  "|",结合括号限制分支范围 "^a(12|34)b"
- 匹配单词的开头和结尾 \b
- 可选匹配：a?表示匹配字符a或者不匹配任何字符
- 量词（匹配字符重复次数）: +(表示之前紧邻的元素出现一次或多次),  *(表示之前紧邻的元素出现任意多次，或者不出现), ...?(可选匹配)
- 区间量词:...{1,3}

### 2.括号和反向引用：分组（表达式组）与捕获

1. 反射引用

    在许多流派（flavor）的正则表达式中，括号能够“记住”它们包含的子表达式组匹配的文本。

    eg: ([A-Za-z]+)(1-3)\1\2，整个正则表达式中有两个表达式组，引用\n表示匹配第n个括号(从左往右数)中的子表达式匹配的内容。

2. 非捕获型括号：(?:...)

我们使用括号来对regex进行分组，这样的副作用就是这个括号内的子表达式获取的文本将被保存。而非捕获型分组，不会影响文本的获取和变量的保存。

### 3. 环视：匹配结果不是字符，而是匹配成功的字符的位置

环视：匹配结果不是字符，而是匹配成功的字符的位置

#### 3.1 顺序环视

顺序环视顺序（从左至右）查看文本，尝试匹配子表达式。

- 肯定型顺序环视(positive lookahread):?=... 子表达式能够匹配左侧文本
- 否定型顺序环视(negative lookahread):?!... 子表达式不能够匹配左侧文本

#### 3.2 逆序环视

它逆序（从右向左）查看文本...。

- 肯定型逆序环视（positive lookbehind）:?<=... 子表达式能够匹配右侧文本
- 否定型逆序环视（negative lookbehind）:?<!... 子表达式不能够匹配右侧文本

### 4. 术语汇总

1. 正则：regex，regular expression 的简写。
2. 匹配（matching）：一个正则表达式“匹配”一个字符串，其实是指这个正则表达式能在字符串中找到匹配文本。
3. 流派（flavor）
