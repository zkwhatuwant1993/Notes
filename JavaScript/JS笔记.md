# JavaScript

## 一、 JS实现

完整的JS实现由以下三部分组成：

- ECMAScript
- DOM
- BOM

### 1.1 ECMAScript:定义了JS的核心语言功能

#### ECMAScript的版本(ES5/6)和兼容性

ES的兼容性：不同浏览器(JS运行环境)各个版本的对ES标准的实现情况。

### 1.2 DOM标准：文档对象模型

文档对象模型（DOM，Document Object Model）是针对XML 但经过扩展用于HTML 的应用程序编程接口（API）。DOM把整个页面映射为一个多层节点结构。

#### DOM级别

DOM1:DOM核心（DOM Core）和DOM HTML.DOM 核心规定的是如何映射基于XML 的文档结构，以便简化对文档中任意部分的访问和操作。DOM HTML 模块则在DOM 核心的基础上加以扩展，添加了针对HTML 的对象和方法。

DOM2:DOM2 级在原来DOM 的基础上又扩充了（DHTML 一直都支持的）鼠标和用户界面事件、范围、遍历（迭代DOM文档的方法）等细分模块，而且通过对象接口增加了对CSS（Cascading Style Sheets，层叠样式表）的支持。以下是DOM2想入的新模块

- DOM视图:定义了跟踪不同文档（例如，应用CSS 之前和之后的文档）视图的接口；
- DOM事件
- DOM遍历和范围

DOM3:xxx

注：和ES标准一样，DOM标准也受浏览器实现的影响。

### 1.3 BOM

Internet Explorer 3 和Netscape Navigator 3 有一个共同的特色，那就是支持可以访问和操作浏览器窗口的浏览器对象模型（BOM，Browser Object Model）。开发人员使用BOM 可以控制浏览器显示的页面以外的部分。而BOM 真正与众不同的地方（也是经常会导致问题的地方），还是它作为JavaScript 实现的一部分但却没有相关的标准。这个问题在HTML5 中得到了解决，HTML5 致力于把很多BOM 功能写入正式规范。HTML5 发布后，很多关于BOM 的困惑烟消云散。

## 严格模式

严格模式为这门语言中容易出错的地方施加了限制。

```javascript
use strict;
```

## 二、 基本概念

### 2.1 数据类型

按照ECMA-262 的定义，JavaScript 的变量与其他语言的变量有很大区别。JavaScript 变量松散类型的本质，决定了它只是在特定时间用于保存特定值的一个名字而已。由于不存在定义某个变量必须要保存何种数据类型值的规则，变量的值及其数据类型可以在脚本的生命周期内改变。

- Undefined：未初始化的变量和函数默认返回值。派生至Null
- Null:仅用于表示对象为空。
- Boolean
- String
- Number
- Object:Object 本质上是由一组无序的名值对组成的

#### typeof:类型检测

#### undefined:未初始化的变量默认值

undefined 值是派生自null, undefined == null 结果为true

#### null:从逻辑角度来看表示一个空对象指针

#### boolean：逻辑值true和false

可以使用Boolean()函数将其他类型转换成boolean类型的值

#### number类型：整数和浮点数

1. 数值范围

    由于内存的限制，ECMAScript 并不能保存世界上所有的数值。ECMAScript 能够表示的最小数值保存在Number.MIN_VALUE 中——在大多   数浏览器中，这个值是5e-324；能够表示的最大数值保存在Number.MAX_VALUE 中——在大多数浏览器中，这个值是    1.7976931348623157e+308。如果某次计算的结果得到了一个超出JavaScript 数值范围的值，那么这个数值将被自动转换成特殊的  Infinity 值。具体来说，如果这个数值是负数，则会被转换成-Infinity（负无穷），如果这个数值是正数，则会被转换成Infinity  （正无穷）。

2. NaN：Not a number
    这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。

    NaN 本身有两个非同寻常的特点:
    - 任何涉及NaN 的操作（例如NaN/10）都会返回NaN
    - NaN 与任何值都不相等，包括NaN 本身

    针对NaN 的这两个特点，ECMAScript 定义了isNaN()函数。这个函数接受一个参数，该参数可以是任何类型，而函数会帮我们确定这个参数是否“不是数值”。isNaN()在接收到一个值之后，会尝试将这个值转换为数值。

3. 数值转换

- Number()
- parseInt()
- parseFloat()

#### String类型

ECMAScript 中的字符串是不可变的

将其他类型的值转换为String使用toString()方法

#### Object类型：ECMAScript 中的对象其实就是一组数据（属性）和功能（函数）的集合

理解一个重要的思想:即在 ECMAScript 中， (就像 Java 中的 java.lang.Object 对象一样)Object 类型是所有它的实例的基类。

Object的每个实例都具有的属性和方法：

- constructor:保存着用于创建当前对象的函数。
- hasOwnProperty(propertyName):用于检查给定的属性在当前对象实例中(而不是在实例 的原型中)是否存在
- isPrototypeOf(object):用于检查传入的对象是否是传入对象的原型
- propertyIsEnumerable(propertyName)
- toLocaleString()
- toString()
- valueOf

### 2.2 操作符

在所有运算中，如果对非数值型数据进行数值转换(有些运算会隐式的先转换，再计算)，调用其Number()方法；进行字符运算调用toString();执行条件语句时如果结果不为Boolean类型会将结果调用Boolean()方法进行转换

#### 位操作符: NaN 和 Infinity 值应用位操作时，这两个值都会被当成 0 来处理

#### 逻辑操作符

1. !

    注意：任何非0的数值的结果都为true,包括undefined,NaN

2. &&

    - 如果第一个操作数是对象，则返回第二个操作数
    - 如果有一个操作数是null,返回null

3. ||

    - 如果第一个操作数是对象，则返回第一个操作数
    - 如果两个操作数都是null，返回null，否则返回非null的那一个操作数。undefined和NaN同理

### 数学运算

### 关系运算

### 相等运算

#### 等于或不等于：强制类型转换

#### 全等或不全等：不类型转换

### 2.3 语句

#### for-in：遍历（枚举）对象属性

如果表示要迭代的对象的变量值为 null 或 undefined，for-in 语句会抛出错误。 ECMAScript 5 更正了这一行为;对这种情况不再抛出错误，而只是不执行循环体。为了保证最大限度的兼容性，建议在使用 for-in 循环之前，先检测确认该对象的值不是 null 或 undefined。

### 2.4 函数

函数对任何语言来说都是一个核心的概念。通过函数可以封装任意多条语句，而且可以在任何地方、任何时候调用执行。

#### 参数：值传递

ECMAScript 中的参数在内部是用一个数组来表示的，函数接收到的始终都是这个数组，而不关心数组中包含哪些参数以及参数的个数。在函数体内可以通过arguments 对象来访问这个参数数组，从而获取传递给函数的每一个参数。

这也就意味着函数的签名仅仅只有函数名，解析器不会验证参数。这个特点也确定了函数不能重载（只能通过判断传入的参数数量来模拟）。

arguments中保存的值与对应命令参数的值保持同步，但它们的内存空间是独立的。

## 三、 变量作用域和内存问题

按照ECMA-262 的定义，JavaScript 的变量与其他语言的变量有很大区别。JavaScript 变量松散类型的本质，决定了它只是在特定时间用于保存特定值的一个名字而已。由于不存在定义某个变量必须要保存何种数据类型值的规则，变量的值及其数据类型可以在脚本的生命周期内改变。

### 3.1 基本类型和引用类型

ECMAScript 变量可能包含两种不同数据类型的值：基本类型值和引用类型值。基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。

5种基本数据类型：Undefined、Null、Boolean、Number 和String。这5 种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。

引用类型的值是保存在内存中的对象。与其他语言不同，JavaScript 不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。为此，引用类型的值是按引用访问的。

#### 动态添加属性

对于引用类型的值，我们可以动态为其添加属性和方法，也可以改变和删除其属性和方法。

#### 复制变量值

基本类型变量和引用类型变量复制都是将原值复制一份到新分配的内存空间(即原值的副本)。

当从一个变量向另一个变量复制值时，会将存储在变量中的值复制一份放到为新变量分配的空间中。需要注意的是，复制引用类型时，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的**同一个对象**。所以操作任意一个指针副本时，改动的都是同一个对象。

#### 参数传递：按值传递

#### 引用类型检测：instanceof

### 3.2 执行环境及作用域:变量的作用域

**执行环境（作用域）**（execution context，为简单起见，有时也称为“环境”）是JavaScript 中最为重要的一个概念。执行环境定义了变量的生命周期，以及哪一部分代码可以访问其中的变量。

**环境变量对象**:每个执行环境都有一个与之关联的变量对象（variable object），**环境中定义的所有变量和函数都保存在这个对象中**。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。

**全局执行环境**是最外围的一个执行环境。根据ECMAScript 实现所在的宿主环境不同，表示执行环境的对象也不一样。在Web 浏览器中，全局执行环境被认为是window 对象，因此所有全局变量和函数都是作为window 对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出——例如关闭网页或浏览器——时才会被销毁）。

**函数执行环境**：**每个函数都有自己的执行环境**。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript 程序中的执行流正是由这个方便的机制控制着。

**作用域链**：当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即arguments 对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自**包含（外部）环境**，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。

**标识符解析**是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。也就是从局部到外部到全局的搜索过程。

```javascript
var color = "blue";

function changeColor(){
    var anotherColor = "red";
    function swapColors(){
        var tempColor = anotherColor;
        anotherColor = color;
        color = tempColor;
        // 这里可以访问color、anotherColor 和tempColor
    }
    // 这里可以访问color 和anotherColor，但不能访问tempColor
    swapColors();
}
// 这里只能访问color
changeColor();
```

以上代码共涉及3 个执行环境：全局环境、changeColor()的局部环境和swapColors()的局部环境。全局环境中有一个变量color 和一个函数changeColor()。changeColor()的局部环境中有一个名为anotherColor 的变量和一个名为swapColors()的函数，但它也可以访问全局环境中的变量color。swapColors()的局部环境中有一个变量tempColor，该变量只能在这个环境中访问到。无论全局环境还是changeColor()的局部环境都无权访问tempColor。然而，在swapColors()内部则可以访问其他两个环境中的所有变量，因为那两个环境是它的父执行环境。

#### 延长作用域块

- try-catch 语句的catch块：对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。
- with

#### JS没有块级作用域

1. 声明变量

    使用var 声明的变量会自动被添加到**最接近的环境中**。在函数内部，最接近的环境就是函数的局部环境；在with 语句中，最接近的环境是函数环境。如果初始化变量时没有使用var 声明，该变量会自动被添加到全局环境。

2. 搜索标识符

    当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到了该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名则继续沿作用域链向上搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中也没有找到这个标识符，则意味着该变量尚未声明。

### 3.3 垃圾回收

JavaScript 具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。这种垃圾收集机制的原理其实很单：找出那些不再继续使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间），周期性地执行这一操作。

垃圾回收策略：标记清除和引用计数

#### 标记清除：mark-and-sweep

#### 引用计数：reference counting

Netscape Navigator 3.0 是最早使用引用计数策略的浏览器，但很快它就遇到了一个严重的问题：循环引用。

**循环引用**指的是对象A 中包含一个指向对象B 的指针，而对象B 中也包含一个指向对象A 的引用。这样这两个对象的引用计数始终是2，永远不会回收。

#### 性能问题

垃圾收集器是周期性运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也是相当大的。在这种情况下，确定**垃圾收集的时间间隔**是一个非常重要的问题。

#### 管理内存

使用具备垃圾收集机制的语言编写程序，开发人员一般不必操心内存管理的问题。但是，JavaScript在进行内存管理及垃圾收集时面临的问题还是有点与众不同。其中最主要的一个问题，就是分配给Web浏览器的可用内存数量通常要比分配给桌面应用程序的少。这样做的目的主要是出于安全方面的考虑，目的是防止运行JavaScript 的网页耗尽全部系统内存而导致系统崩溃。内存限制问题不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。

因此，确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为null 来标记其引用可以释放——这个做法叫做**解除引用（dereferencing）**。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动被解除引用。

## 四、 引用类型

引用类型的值（对象）是某个特定引用类型的一个实例。在ECMAScript 中，引用类型是一种**数据结构**，用于将数据和功能组织在一起。它也常被称为类，但这种称呼并不妥当。尽管ECMAScript从技术上讲是一门面向对象的语言，但它不具备传统的面向对象语言所支持的类和接口等基本结构。引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。

新对象是使用new 操作符后跟一个构造函数来创建的。**构造函数**本身就是一个函数，只不过该函数是出于创建新对象的目的而定义的

### 4.1 Object类型

```javascript
// 使用构造函数
var person = new Object();
person.name = "zyy";
persion.age = "18";

/**
*
* 对象字面量:简化创建包含大量属性的对象的过程.
* 就是花括号里边包含 key:value对(属性名:属性值)，多个属性用逗号分隔
*
* **使用字面量创建Object实现不会调用构造方法**
*/

var person = {
    name: "zyy",
    age: 18
}
```

tip:一般来讲，命名参数虽然容易处理，但在有多个可选参数的情况下就会显示不够灵活。最好的做法是对那些必需值使用命名参数，而使用对象字面量来封装多个可选参数。

#### 访问对象中的属性

```javascript
// 1. 使用点号
person.name

// 2. 使用[]，当需要**使用变量来访问对象属性**时使用这种方法，否则用点号
person["name"]
```

### 4.2 Array类型

除了Object 之外，Array 类型恐怕是ECMAScript 中最常用的类型了。而且，ECMAScript 中的数组与其他多数语言中的数组有着相当大的区别。虽然ECMAScript 数组与其他语言中的数组都是数据的有序列表，但与其他语言不同的是，ECMAScript 数组的**每一项可以保存任何类型的数据**。也就是说，可以用数组的第一个位置来保存字符串，用第二位置来保存数值，用第三个位置来保存对象，以此类推。而且，ECMAScript 数组的大小是**可以动态调整**的，即可以随着数据的添加自动增长以容纳新增数据。

#### 创建Array实例

```javascript
// 1. 构造函数
var arr = new Array(params);
//创建数据可以省略new
var arr = Array(params);

// 2. 字面量：和Object一样，使用字面量创建Array实例不会调用其构造方法
var arr = [1,2];
var arr = [];
```

#### 访问数组元素（索引）和动态性

数组索引：0 ~ length-1。

由于数组的动态性，可以在运行时手动**改变数组的length属性**和通过给**超出数组索引范围的项赋值**来改变数组长度。

#### 判断对象是否为数组:Array.isArray()

自从ECMAScript 3 做出规定以后，就出现了确定某个对象是不是数组的经典问题。对于一个网页，或者一个全局作用域而言，使用instanceof 操作符就能得到满意的结果。

instanceof 操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array 构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。

为了解决这个问题，ECMAScript 5 新增了Array.isArray()方法。这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的

#### 转换其他类型

- toString()
- toLocalString()
- toValueOf()
- join()

join():数组继承的toLocaleString()、toString()和valueOf()方法，在默认情况下都会以**逗号分隔的字符串**的形式返回数组项。而如果使用join()方法，则可以使用不同的分隔符来构建这个字符串。

如果数组中的某一项的值是null 或者undefined，那么该值在join()、toLocaleString()、toString()和valueOf()方法返回的结果中以空字符串表示。

#### 栈方法：将数组视为一个栈使用

- push()
- pop()

#### 队列方法

- shift()
- unshift()

#### 数组排序

- reverse()
- sort()，此方法还可以转递一个用于排序的函数

这两个方法的返回值都是排序之后的数组，不影响原数组（即排序的是原数组的一个副本）。

#### 操作方法

- concat()
- slice()
- splice()：向数组中插入项。利用该方法可以实现删除、插入、替换数组中的项。

#### 查找项的位置

- indexOf()
- lastIndexOf()

这两个方法在查找的时候都是进行全等判断，如找到返回所在位置，未找到返回-1。

#### 数组迭代

ECMAScript 5 为数组定义了5 个迭代方法。每个方法都接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象——影响this 的值。这个函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。根据使用的方法不同，这个函数执行后的返回值可能会也可能不会影响方法的返回值。

- every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true。
- filter()：对数组中的每一项运行给定函数，返回该函数会返回true 的项组成的数组。
- forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。
- map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。
- some()：对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。

#### 并归（合并）操作

ECMAScript 5 还新增了两个归并数组的方法：reduce()和reduceRight()。这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。其中，reduce()方法从数组的第一项开始，逐个遍历到最后。而reduceRight()则从数组的最后一项开始，向前遍历到第一项。

- reduce()
- reduceRight()

这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。

并归调用的函数接收4 个参数：前一个值（第一次调用时该值为数组第一项)，此后这个值为前一次并归操作函数的返回值）、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代**发生在数组的第二项**上，**因此第一个参数是数组的第一项**，第二个参数就是数组的第二项。

### 4.3 Date类型

```javascript
// 创建对象，用无参构造创建的Date对象获取的时间是当前时间。
var date = new Date();

// 带日期字符串参数,内部也是调用Date.parese()来解析该字符串
var someDate = new Date("May 25, 2004");
```

- Date.parse()
- Date.UTC()
- Data.now()  //es5

#### 从Object继承的方法

#### 日期格式化方法

- toDateString()——以特定于实现的格式显示星期几、月、日和年；
- toTimeString()——以特定于实现的格式显示时、分、秒和时区；
- toLocaleDateString()——以特定于地区的格式显示星期几、月、日和年；
- toLocaleTimeString()——以特定于实现的格式显示时、分、秒；
- toUTCString()——以特定于实现的格式完整的UTC 日期。

与toLocaleString()和toString()方法一样，以上这些字符串格式方法的输出也是因浏览器
而异的，因此没有哪一个方法能够用来在用户界面中显示一致的日期信息。

#### 日期/时间组件方法:获取日期中特定部分的值

### 4.4 RegExp类型

```javascript
//字面量
var expression = / pattern / flags ;

//构造函数，与字面的区别是，由于构造函数的参数是字符串，匹配的字符包括元字符时要进行双重转义
var exp = new RegExp(patternStr,flagStr);

// 例如,以下两个实例等价
var exp1 = /\[bc\]at/i
var exp2 = new RegExp("\\[bc\\]at", "i");
```

其中的模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、
向前查找以及反向引用。每个正则表达式都可带有一或多个标志（flags），用以标明正则表达式的行为。
正则表达式的匹配模式支持下列3 个标志。

- g：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；
- i：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；
- m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。

#### 实例属性

通过这些属性可以获知一个正则表达式的各方面信息，但却没有多大用处，因为这些信息全都包含在模式声明中。

- global：布尔值，表示是否设置了g 标志。
- ignoreCase：布尔值，表示是否设置了i 标志。
- lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0 算起。
- multiline：布尔值，表示是否设置了m 标志。
- source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。

#### 实例方法

1. exec():专门为捕获组而设计的方法
    对于exec()方法而言，即使在模式中设置了全局标志（g），它每次也只会返回一个匹配项。在不
设置全局标志的情况下，在同一个字符串上多次调用exec()将始终返回第一个匹配项的信息。而在设
置全局标志的情况下，每次调用exec()则都会在字符串中继续查找新匹配项

2. test()

RegExp 实例继承的toLocaleString()和toString()方法都会返回正则表达式的字面量。

#### RegExp构造函数属性:其他语言被看成静态属性(也就是通过类弄名称直接调用，不用实例化)

长属性名 | 别名 | 功能
------- | ------- | -------
RegExp.input | RegExp["$_"] | 最近一次要匹配的字符串。Opera未实现此属性
RegExp.lastMatch | RegExp["$&"] | 最近一次的匹配项。Opera未实现此属性
RegExp.lastParen | RegExp["$+"] | 最近一次匹配的捕获组。Opera未实现此属性
RegExp.leftContext | RegExp["$`"] | input字符串中lastMatch之前的文本
RegExp.multiline | RegExp["$*"] | 布尔值，表示是否所有表达式都使用多行模式。IE和Opera未实现此属性
RegExp.rightContext | RegExp["$'"] | Input字符串中lastMatch之后的文本

上面的几个属性之外，还有9 个用于存储捕获组的构造函数属性。$1 至 $9

### 4.5 Function类型

说起来ECMAScript 中什么最有意思，莫过于函数了——而有意思的根源，则在于**函数实际上是对象**。每个函数都是Function 类型的实例，而且都与其他引用类型一样具有属性和方法。由于函数是对象，因此**函数名实际上也是一个指向函数对象的指针**，不会与某个函数绑定。

```javascript
//函数的定义方式
// 1. 函数声明
function sum (num1, num2) {
    return num1 + num2;
}

// 2. 表达式
var sum = function(sum1, sum2) {
    return num1 + num2;
}

/*
  3. 构造函数
  从技术角度讲，这是一个函数表达式。但是，我们不推荐读者使用这种方法定义函数，因为这种语法会导致解析两次代码（第一次是解析常规ECMAScript 代码，第二次是解析传入构造函数中的字符串），从而影响性能。不过，这种语法对于理解“函数是对象，函数名是指针”的概念倒是非常直观的。
*/
var sum = new Function("num1", "num2", "return num1 + num2");

```

#### 没有重载(深入理解)

将函数名想象为指针，也有助于理解为什么ECMAScript 中没有函数重载的概念。

```javascript
function addSomeNumber(num){
    return num + 100;
}
function addSomeNumber(num) {
    return num + 200;
}
var result = addSomeNumber(100);


//显然，这个例子中声明了两个同名函数，而结果则是后面的函数覆盖了前面的函数。以上代码实际上与下面的代码没有什么区别。
var addSomeNumber = function (num){
    return num + 100;
};
addSomeNumber = function (num) {
    return num + 200;
};
var result = addSomeNumber(100);

//通过观察重写之后的代码，很容易看清楚到底是怎么回事儿——在创建第二个函数时，实际上覆盖了引用第一个函数的变量addSomeNumber。
```

#### 函数声明与函数表达式的区别：函数声明提升

解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。

因为在代码开始执行之前，解析器就已经通过一个名为函数声明提升（function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。对代码求值时，JavaScript引擎在第一遍会声明函数并将它们放到源代码树的顶部。所以，即使声明函数的代码在调用它的代码后面，JavaScript 引擎也能把函数声明提升到顶部。

```javascript
//函数声明定义，函数提升，可以执行。
alert(sum(10,10));
function sum(num1, num2){
    return num1 + num2;
}

// 表达式定义，按顺序执行，所以会报错
alert(sum(10,10));
var sum = function(num1, num2){
    return num1 + num2;
};
```